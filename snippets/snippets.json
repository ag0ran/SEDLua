{
  "assert": {
    "body": "assert(${1:v}${2:[, message]})",
    "description": "assert()\nIssues an error when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to \"assertion failed!\"",
    "prefix": "assert"
  },
  "dofile": {
    "body": "dofile(${1:[filename]})",
    "description": "Opens the named file and executes its contents as a Lua chunk. Returns all values returned by the chunk. In case of errors, dofile propagates the error to its caller (that is, dofile does not run in protected mode).",
    "prefix": "dofile"
  },
  "elif": {
    "body": "else if ${1:condition} then\n\t${0:-- body}\n",
    "description": "elif",
    "prefix": "elif"
  },
  "for": {
    "body": "for ${1:i}=${2:1},${3:10} do\n\t${0:print(i)}\nend",
    "description": "for i=1,10",
    "prefix": "for"
  },
  "fori": {
    "body": "for ${1:i},${2:v} in ipairs(${3:table_name}) do\n\t${0:print(i,v)}\nend",
    "description": "for i,v in ipairs()",
    "prefix": "fori"
  },
  "forp": {
    "body": "for ${1:k},${2:v} in pairs(${3:table_name}) do\n\t${0:print(k,v)}\nend",
    "description": "for k,v in pairs()",
    "prefix": "forp"
  },
  "fun": {
    "body": "function ${1:function_name}(${2:...})\n\t${0:-- body}\nend",
    "description": "function",
    "prefix": "function"
  },
  "if": {
    "body": "if ${1:condition} then\n\t${0:-- body}\nend",
    "description": "if",
    "prefix": "if"
  },
  "ifel": {
    "body": "if ${1:condition} then\n\t${2:-- body}\nelse\n\t${0:-- body}\nend",
    "description": "ifel",
    "prefix": "ifel"
  },
  "ipairs": {
    "body": "ipairs(${0:...})",
    "prefix": "ipairs"
  },
  "local": {
    "body": "local ",
    "description": "local",
    "prefix": "local"
  },
  "pairs": {
    "body": "pairs(${0:...})",
    "description": "5.1,5.2,5.3\n\npairs (t)",
    "prefix": "pairs"
  },
  "print": {
    "body": "print(${1:...})",
    "description": "Receives any number of arguments, and prints their values to stdout, using the tostring function to convert them to strings. print is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use string.format.",
    "prefix": "print"
  },
  "ret": {
    "body": "return",
    "description": "return",
    "prefix": "ret"
  },
  "select": {
    "body": "select(${1:index}, ${2:...})",
    "description": "If index is a number, returns all arguments after argument number index. Otherwise, index must be the string \"#\", and select returns the total number of extra arguments it received.",
    "prefix": "select"
  },
  "string.char": {
    "body": "string.char(${1:...})",
    "description": "Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numerical code equal to its corresponding argument.",
    "prefix": "string.char",
    "scope": "source.lua"
  },  
  "string.dump": {
    "body": "string.dump(${0:...})",
    "description": "Returns a string containing a binary representation of the given function, so that a later loadstring on this string returns a copy of the function. function must be a Lua function without upvalues.",
    "prefix": "string.dump"
  },
  "string.find": {
    "body": "string.find(${1:s},${2:pattern}${3:[, init]}${4:[, plain]})",
    "description": "Looks for the first match of pattern in the string s. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative. A value of true as a fourth, optional argument plain turns off the pattern matching facilities, so the function does a plain \"find substring\" operation, with no characters in pattern being considered \"magic\". Note that if plain is given, then init must be given as well.",
    "prefix": "string.find",
    "scope": "source.lua"
  },
  "string.format": {
    "body": "string.format(\"${1:formatstring}\",${2:...})",
    "description": "Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the printf family of standard C functions. The only differences are that the options/modifiers *, l, L, n, p, and h are not supported and that there is an extra option, q. The q option formats a string in a form suitable to be safely read back by the Lua interpreter: the string is written between double quotes, and all double quotes, newlines, embedded zeros, and backslashes in the string are correctly escaped when written.",
    "prefix": "string.format",
    "scope": "source.lua"
  },
  "string.gmatch": {
    "body": "string.gmatch(${1:s},${2:pattern})",
    "description": "Returns an iterator function that, each time it is called, returns the next captures from pattern over string s. If pattern specifies no captures, then the whole match is produced in each call.",
    "prefix": "string.gmatch",
    "scope": "source.lua"
  },
  "string.gsub": {
    "body": "string.gsub(${1:s},${2:pattern},${3:repl}${4:[, n]})",
    "description": "Returns a copy of s in which all (or the first n, if given) occurrences of the pattern have been replaced by a replacement string specified by repl, which can be a string, a table, or a function. gsub also returns, as its second value, the total number of matches that occurred. If repl is a string, then its value is used for replacement. The character % works as an escape character: any sequence in repl of the form %n, with n between 1 and 9, stands for the value of the n-th captured substring (see below). The sequence %0 stands for the whole match. The sequence %% stands for a single %. If repl is a table, then the table is queried for every match, using the first capture as the key; if the pattern specifies no captures, then the whole match is used as the key.     If repl is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order; if the pattern specifies no captures, then the whole match is passed as a sole argument. If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement (that is, the original match is kept in the string).",
    "prefix": "string.gsub",
    "scope": "source.lua"
  },
  "string.len": {
    "body": "string.len(${1:s})",
    "description": "Receives a string and returns its length. The empty string \"\" has length 0. Embedded zeros are counted, so \"a\\000bc\\000\" has length 5.",
    "prefix": "string.len",
    "scope": "source.lua"
  },
  "string.lower": {
    "body": "string.lower(${1:s})",
    "description": "Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.",
    "prefix": "string.lower",
    "scope": "source.lua"
  },
  "string.match": {
    "body": "string.match(${1:s},${2:pattern}${3:[, init]})",
    "description": "Looks for the first match of pattern in the string s. If it finds one, then match returns the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative.",
    "prefix": "string.match",
    "scope": "source.lua"
  },
  "string.rep": {
    "body": "string.rep(${1:s}, ${2:n}${3:[, rep]})",
    "description": "Returns a string that is the concatenation of n copies of the string s.",
    "prefix": "string.rep",
    "scope": "source.lua"
  },
  "string.reverse": {
    "body": "string.reverse(${1:s})",
    "description": "Returns a string that is the string s reversed.",
    "prefix": "string.reverse",
    "scope": "source.lua"
  },
  "string.sub": {
    "body": "string.sub(${1:s}, ${2:i}${3:[, j]})",
    "description": "Returns the substring of s that starts at i and continues until j; i and j can be negative. If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) returns a suffix of s with length i.",
    "prefix": "string.sub",
    "scope": "source.lua"
  },
  "string.upper": {
    "body": "string.upper(${1:s})",
    "description": "Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.",
    "prefix": "string.upper",
    "scope": "source.lua"
  },
  "table.concat": {
    "body": "table.concat(${1:tablename}${2:, \", \"}${3:, start_index}${4:, end_index})",
    "description": "Given an array where all elements are strings or numbers, returns table[i]..sep..table[i+1] ··· sep..table[j]. The default value for sep is the empty string, the default for i is 1, and the default for j is the length of the table. If i is greater than j, returns the empty string.",
    "prefix": "table.concat",
    "scope": "source.lua"
  },
  "table.insert": {
    "body": "table.insert(${1:list},${2: [pos,]}${3: value})",
    "description": "Inserts element value at position pos in table, shifting up other elements to open space, if necessary. The default value for pos is n+1, where n is the length of the table (see §2.5.5), so that a call table.insert(t,x) inserts x at the end of table t.",
    "prefix": "table.insert",
    "scope": "source.lua"
  },
  "table.maxn": {
    "body": "table.maxn(${0:...})",
    "description": "Returns the largest positive numerical index of the given table, or zero if the table has no positive numerical indices. (To do its job this function does a linear traversal of the whole table.)",
    "prefix": "table.maxn",
    "scope": "source.lua"
  },
  "table.remove": {
    "body": "table.remove(${1:list},${2: [pos,]})",
    "description": "Removes from table the element at position pos, shifting down other elements to close the space, if necessary. Returns the value of the removed element. The default value for pos is n, where n is the length of the table, so that a call table.remove(t) removes the last element of table t.",
    "prefix": "table.remove",
    "scope": "source.lua"
  },
  "table.sort": {
    "body": "table.sort(${1:tablename}${2:, sortfunction})",
    "description": "Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length of the table. If comp is given, then it must be a function that receives two table elements, and returns true when the first is less than the second (so that not comp(a[i+1],a[i]) will be true after the sort). If comp is not given, then the standard Lua operator < is used instead.",
    "prefix": "table.sort",
    "scope": "source.lua"
  },
  "tonumber": {
    "body": "tonumber(${1:e}${2:[, base]})",
    "description": "Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.\nAn optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter 'A' (in either upper or lower case) represents 10, 'B' represents 11, and so forth, with 'Z' representing 35. In base 10 (the default), the number can have a decimal part, as well as an optional exponent part (see §2.1). In other bases, only unsigned integers are accepted.",
    "prefix": "tonumber",
    "scope": "source.lua"
  },
  "tostring": {
    "body": "tostring(${1:v})",
    "description": "Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format.\nIf the metatable of e has a \"__tostring\" field, then tostring calls the corresponding value with e as argument, and uses the result of the call as its result.",
    "prefix": "tostring",
    "scope": "source.lua"
  },
  "type": {
    "body": "type(${1:v})",
    "description": "Returns the type of its only argument, coded as a string. The possible results of this function are \"nil\" (a string, not the value nil), \"number\", \"string\", \"boolean\", \"table\", \"function\", \"thread\", and \"userdata\".",
    "prefix": "type",
    "scope": "source.lua"
  },
  "unpack": {
    "body": "unpack(${0:...})",
    "description": "Returns the elements from the given table. This function is equivalent to\n\nreturn list[i], list[i+1], ···, list[j]\n\nexcept that the above code can be written only for a fixed number of elements. By default, i is 1 and j is the length of the list, as defined by the length operator",
    "prefix": "unpack",
    "scope": "source.lua"
  },
  "while": {
    "body": "while ${0:condition} do\n\t${1:--body}\nend",
    "description": "while loop, repeats while the condition evaluates to true.",
    "prefix": "while"
  },
  "do": {
    "body": "do",
    "description": "\"do\" keyword, part of various control statements.",
    "prefix": "do"
  },
  "then": {
    "body": "then",
    "description": "\"then\" keyword, part of various control statements.",
    "prefix": "then"
  },
  "dow": {
    "body": "do\n\t${0:--body}\nwhile ${1:condition}",
    "description": "do-while loop, repeats while the condition evaluates to true but will execute the loop at least once.",
    "prefix": "dow"
  }
}